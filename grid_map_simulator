int w = 10, h = 10, bs = 60;
/*
w = number of columns
h = number of rows
bs = pixels per box
*/
float obs = bs * 0.8; //obstacle size

float wp = bs * 0.8; //waypoint size

float mp = (bs - obs)/2; //midpoint of grid to draw object

int[][] board = new int[h][w];

int[] segments = new int[8];
int v = 0; //coordniates counter

ArrayList<int[]> segmentList;

Boolean segmentMode = false;

void setup(){
  size(600, 600); //change according to (w*bs) and (h*bs)
  ellipseMode(CORNER);
  segmentList = new ArrayList<int[]>();
}

void draw(){
  for(int j=0; j<h; j++){
    for(int i=0; i<w; i++){
      fill(255);
      stroke(0);
      rect(i*bs, j*bs, bs, bs);
      if(board[j][i] == -1){
        fill(0, 0, 0);
        noStroke();
        rect(((i*bs)+mp), ((j*bs)+mp), obs, obs);      
      }
      else
        if(board[j][i] == 2){
          fill(255, 0, 0);
          noStroke();
          ellipse(((i*bs)+mp), ((j*bs)+mp), wp, wp);
        }
    }  
  } 
}

void mouseDragged(){
  board[mouseY/bs][mouseX/bs] = -1; 
}

void mousePressed(){
  board[mouseY/bs][mouseX/bs] = board[mouseY/bs][mouseX/bs] * -1;
  
  if(segmentMode == true){
    segments[v*2] = (mouseX/bs);
    segments[(v*2)+1] = (mouseY/bs);
    v++;
    if(v == 4){
      segmentList.add(new int[]{segments[0], segments[1], segments[2], segments[3], segments[4], segments[5], segments[6], segments[7]});
      segmentMode = false;
      for(int[] row : segmentList){
        println(row);
      }
      v = 0;
    }
  }
}

void keyPressed(){
  if((key == 'W') || (key == 'w')){ //set waypoint by moving the cursor onto the grid and press 'w'
    board[mouseY/bs][mouseX/bs] = 2;
  }
  if((key == 'I') || (key == 'i')){ //export the grid map as an image 
    save("map.jpg");
  }
  if((key == 'D') || (key == 'd')){ 
    segmentMode = true;
  }
}
